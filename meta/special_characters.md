**Что нужно имплементировать по сабджекту**
- working history (символ '!!' ?)
- Search and launch the right executable (based on the PATH variable or using a
relative or an absolute path). (/, ., .., $)
- ''', '"'
- < > << >>
- |
- ctrl-C, ctrl-D and ctrl-\


**Документация**

**Специальные Символы**:
| & : ; ( ) < > ~ * @ ? ! $ # [ ] { } \ / ` . " ' , 

--------------------------------------------------------------------------

'#'
Начало комментария.
Все что следует за этим символом, является комментарием, исключением является только комбинация #! стоящая в первой строке. Любые команды, следующие за этим символом в одной строке, будут считаться комментариями и выполнены не будут.
Если данный символ экранирован или заключен в одинарные или двойные кавычки, он будет выступать в роли обычного символа. Кроме того он может быть использован в операциях подстановки параметров и в константных числовых выражениях.

Примеры:
echo "Здесь символ # не является началом комментария."
echo 'Здесь символ # тоже не является началом комментария.'
echo Здесь экранированный символ \# тоже не является началом комментария.
echo А здесь # означает комментарий.
 
echo ${PATH#*:}       # Подстановка параметров -- символ # не является началом комментария.
echo $(( 2#101011 ))  # База системы счисления -- символ # не является началом комментария.
--------------------------------------------------------------------------

'.'
При использовании внутри сценария, позволяет подгружать внешний файл, например с данными или функциями.<
Например, есть файл test.sh содержащий следующий сценарий:
#!/bin/bash
 
. var.file  # загружаем переменные из внешнего файла 
echo $var  # выводим значение переменной
файл var.file содержит всего одну строку, где переменной $var присваивается значение Hello world !

var="Hello world !"
Запускаем сценарий test.sh

freebsd /# ./test.sh
Hello world !
Так-же "точка" может быть частью имени файла. Если имя файла начинается с точки, как правило, такой файл будет скрытым для просмотра командой ls ( зависит от оболочки ).

Если речь идет о каталогах, одна точка означает текущий каталог, две точки каталог уровнем выше, то есть родительский.

Команду точка, удобно использовать при копировании или перемещении объектов файловой системы. Например так:

freebsd /# cp /path/to/dir/* . # Копировать все файлы из директории /path/to/dir/ в текущую директорию
При операциях поиска по шаблону и в регулярных выражениях, символ точка означает любой одиночный символ.
--------------------------------------------------------------------------

'"'
В строке, заключенной в двойные кавычки, не интерпретируются ( экранируются ) большинство служебных символов (все крому $)
--------------------------------------------------------------------------

'''
Более строгий вариант экранирования. В строке, заключенной в одинарные кавычки, не будут интерпретированы любые служебные символы.
--------------------------------------------------------------------------

',' - **НЕ ПОНЯЛА, НУЖНО ЛИ РЕАЛИЗОВЫВАТЬ**
Команда запятая, используется для вычисления нескольких арифметических выражений. Несмотря на то, что вычислены будут все выражения, результат будет выведен только из последней операции. Например, такой скрипт:
let "result = ((a= 5 + 3, b= 7 - 1, c= 15 - 4))"
echo $a
echo $b
echo $c
echo $result
--------------------------------------------------------------------------

'\'
Используется в качестве разделителя в путях директорий и файлов, в операционных системах Unix.
При использовании в арифметических операциях, означает - деление.
--------------------------------------------------------------------------

'`'
Подстановка команд
Могут использоваться для присвоения переменной, результатов выражения системной команды. Скрипт:
result= `hostname` # результат команды hostname присваиваем переменной 
echo $result
--------------------------------------------------------------------------

':'
Данную команду можно считать эквивалентом встроенной команды true. Как и true, команда двоеточие, всегда возвращает 0, то есть true

Возможны следующие варианты использования.
Бесконечный цикл:
while :
do
echo "test"
done
 
Символ заполнитель в условном операторе if/then.
a=1
b=2
if [ $a = $b ]
then :      # Не производить никаких действий
else
echo "test"  # поскольку условие возвращает false ( $a не равно $b ), будет выполнена эта строка
fi

Символ заполнитель в операциях, предполагающих наличие двух операндов.
: ${username=`whoami`} # без символа двоеточия будет выдано сообщение об ошибке

Символ заполнитель в конструкциях вложенный документ.
В операциях с подстановкой параметров.
: ${HOSTNAME?} ${USER?} ${MAIL?} # если одна или несколько переменных не определены, будет выведено сообщение об ошибке

В операциях замены подстроки с подстановкой переменных.
В сочетании с операторами перенаправления вывода
При использовании с оператором >, обнуляет содержимое файла, если файла не существует, он создается:
: > data.file  # этой командой файл <em>data.file</em> будет очищен до нуля.

Того-же можно добиться с помощью команды cat /dev/null > data.file, только в этом случае создается новый процесс.
В сочетании с оператором >> перенаправление с добавлением в конец файла и изменением времени последнего доступа.
: >> data.file

Так-же символ двоеточие используется в качестве разделителя полей в файле /etc/passwd и переменной окружения $PATH.
freebsd /# echo $PATH
/sbin:/bin:/usr/sbin:/usr/bin:/usr/games:/usr/local/sbin:/usr/local/bin:/root/bin
--------------------------------------------------------------------------

'!'
Логическое отрицание в условных операторах
используется для инвертирования кода возврата операции к которой он применяется. Так-же применяется для логического отрицания в операциях сравнения

При использовании из командной строки оболочки, запускает механизм работы с историей команд
!!			Выполнить последнюю введённую команду
--------------------------------------------------------------------------

'*'
Используется в качестве шаблона для постановки в имени файла. В случае использования одиночного символа шаблона, означает совпадение с любым именем файла.
echo *.md

В регулярном выражении, означает 0 или больше, любых символов.
В арифметических операциях знак * - означает умножение, а в варианте ** - возведение в степень.
--------------------------------------------------------------------------

'?'
В некоторых случаях используется для проверки выполнения условия.
При использовании в конструкциях с двойными скобками, ведет себя как тернарный оператор языка C

При использовании в выражениях с подстановкой параметров, проверяет установлено-ли значение переменной.
: ${HOSTNAME?} ${USER?} ${MAIL?}
# если одна или несколько переменных не определены, будет выведено сообщение об ошибке
Кроме того используется как символ шаблон. При подстановке к имени файла и в регулярных выражениях, означает одиночный символ.
--------------------------------------------------------------------------

'$'
Подстановка переменной
Установка символа $ перед именем переменной, означает что будет получено значение данной переменной.
В регулярных выражениях, означает конец строки.
--------------------------------------------------------------------------

'()'
Группа команд
Команды размещенные в скобках, выполняются в дочернем процессе ( subshell ). При этом переменные, определяемые в дочернем процессе, не видны в родительском.
Может быть инициализацией массива
--------------------------------------------------------------------------

'{}'
Интерпретируется как список возможных вариантов. Например, следующая команда сценария, производит поиск строки test в файлах data.1, data.2, data.3.
grep test data.{1,2,3*}

Или блок кода
--------------------------------------------------------------------------

'[ ]'
В конструкции с квадратными скобками, проверяется истинность включенного в него выражения.
При работе с массивами, в квадратных скобках указывается индекс элемента к которому нужно обратиться.
--------------------------------------------------------------------------

'>, &>, >&, >>, <'
Перенаправление ввода/вывода
В любой unix системе, по умолчанию открыто три файла stdin ( стандартный поток ввода - клавиатура ), stdout ( стандартный потов вывода - экран ) и stderr ( стандартный поток вывода ошибок ), дескрипторы 0,1 и 2, соответственно.
Операторы перенаправления позволяют передать вывод из файла, сценария, команды или блока команд на ввод другого файла, сценария, команды. Например:

freebsd /# ./test.sh > outfile  # перенаправление вывода сценария stdout в файл outfile
freebsd /# command &> outfile # перенаправление выводов stdout и stderr команды в файл outfile
freebsd /# command >&2 # перенаправление вывода stdout команды в поток stderr
freebsd /# ./test.sh >> outfile # перенаправление вывода сценария stdout в файл, в режиме добавления в конец файла
Операция подстановки процесса, передает вывод одного процесса на ввод другого.

(command)>
<(command)
между символами <, > и круглой скобкой не должно быть пробела.

Кроме того символы < и > используются в операциях сравнения символов и целых чисел.
--------------------------------------------------------------------------

'<<'
Перенаправление на встроенный документ

--------------------------------------------------------------------------

'|'
Конвейер ( канал, pipe ), это классический способ межпроцессного взаимодействия, stdout одного процесса, передается на stdin другого. Часто используется для связывания нескольких команд между собой. Одна команда, передает результат обработки данных через конвейер на ввод другой команды. Например, вывод команды ps ( process status - список процессов ), передается на ввод команде grep ( поиск по шаблону ), которая в свою очередь, сделав выборку, выводит результат в stdout.

(cat special_characters.md | wc -l)
--------------------------------------------------------------------------

'&'
Выполнить процесс в фоновом режиме

&& - логическое и
--------------------------------------------------------------------------

'-'
Часто дефис предшествует опциям команд. (ls -l)
Перенаправление из/в stdin или stdout
--------------------------------------------------------------------------

'='
символ равно
--------------------------------------------------------------------------

'+'
символ плюс
--------------------------------------------------------------------------

'%'
символ модуль
В зависимости от контекста использования, остаток от деления в арифметических операциях или выступает в качестве шаблона.
В шаблонах, удаляет из переменной большую или меньшую подстроку, совпадающую с шаблоном. Поиск ведется с конца строки.
--------------------------------------------------------------------------

'~'
Домашний каталог ( тильда )
Соответствует переменной окружения $HOME, содержащей путь к домашнему каталогу текущего пользователя.
--------------------------------------------------------------------------

'^'
Начало строки
При использовании в регулярных выражениях, обозначает начало строки текста.
--------------------------------------------------------------------------

'$*, $@'
параметры командной строки.
$0, $1, $2 и т.д.
аргументы передаются... из командной строки в сценарий, функциям или команде set (см. Пример 4-5 и Пример 11-13)
$#
количество аргументов командной строки [2], или позиционных параметров (см. Пример 33-2)
$*
Все аргументы в виде одной строки (слова)
$@
То же самое, что и $*, но при этом каждый параметр представлен как отдельная строка (слово), т.е. параметры не подвергаются какой либо интерпретации.

--------------------------------------------------------------------------
'\' - **НЕ НУЖНО РЕАЛИЗОВЫВАТЬ**
escape character - Символ после этого символа не считается специальным
--------------------------------------------------------------------------

';' - **НЕ НУЖНО РЕАЛИЗОВЫВАТЬ**
Разделитель команд, Позволяет записывать более одной команды в строке.

echo hello; echo there
--------------------------------------------------------------------------

**Hot keys**

В качестве управляющего символа, управляет выводом текста или поведением терминала. Набирается на клавиатуре как сочетание Ctrl+клавиша.

Ctrl+C - Прервать выполнение процесса. **НАДО РЕАЛИЗОВАТЬ**
Ctrl+D - Выход из системной оболочки, аналог команды exit или EOF- конец файла, так-же выступает завершающим символом при вводе с stdin.  **НАДО РЕАЛИЗОВАТЬ**
Ctrl+\ - does nothing **НАДО РЕАЛИЗОВАТЬ**
Ctrl+G - BEL, звуковой сигнал.
Ctrl+H - Backspace, удалить предыдущий символ.
Ctrl+J - Возврат каретки.
Ctrl+L - Аналог команды clear, очистка окна терминала.
Ctrl+M - Перевод строки.
Ctrl+U - Очистить строку ввода.
Ctrl+X - Приостановить выполнение процесса.

--------------------------------------------------------------------------
Источники:
- в основном https://vds-admin.ru/shell-scripting/sluzhebnye-simvoly
- https://sonikelf.ru/15-specialnyx-simvolov-komand-kotoryx-nuzhno-znat-dlya-raboty-bash-linux/
- https://www.opennet.ru/docs/RUS/bash_scripting_guide/c301.html