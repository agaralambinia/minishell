Объявление:

    struct  sigaction 
    {
        union __sigaction_u __sigaction_u;  /* signal handler */
        sigset_t sa_mask;                   /* signal mask to apply */
        int     sa_flags;                   /* see signal options below */
    };

    union __sigaction_u 
    {
        void    (*__sa_handler)(int);
        void    (*__sa_sigaction)(int, siginfo_t *, void *);
     };


    int sigaction(int sig, const struct sigaction *restrict act, struct sigaction *restrict oact);

Header files:

    <signal.h>

Система определяет набор сигналов, которые могут быть доставлены процессу.  Доставка сигнала напоминает возникновение аппаратного прерывания: сигнал обычно блокируется от дальнейшего появления, текущий контекст процессa сохраняется, и создается новый.  Процесс может указать обработчик, которому будет доставлен сигнал, или указать, что сигнал должен быть проигнорирован.  Процесс также может указать действие по умолчанию, которое будет предпринято системой при возникновении сигнала.  Сигнал также может быть заблокирован, в этом случае его доставка откладывается до тех пор, пока он не будет разблокирован.  Действие, которое будет предпринято при доставке, определяется в момент доставки.  Обычно обработчики сигналов выполняются в текущем стеке процесса.  Это может быть изменено для каждого обработчика таким образом, чтобы сигналы приниматься в специальном сигнальном стеке.

Сигнальные подпрограммы обычно выполняются с заблокированным сигналом, вызвавшим их вызов, но могут появиться и другие сигналы.  Глобальная маска сигналов определяет набор сигналов, которые в данный момент заблокированы от доставки в процесс.  Маска сигналов для процесса инициализируется маской сигналов его родителя (обычно пустой).  Она может быть изменена с помощью команды sigprocmask(2) или когда процессу доставляется сигнал.

Когда возникает условие сигнала для процесса, сигнал добавляется в набор сигналов, ожидающих обработки.
Если сигнал в данный момент не заблокирован процессом, то он доставляется процессу.  Сигналы могут быть доставлены в любое время, когда процесс входит в операционную систему (например, во время системного вызова, ошибки или ловушки страницы, или прерывании счетчика).  Если несколько сигналов готовы к передаче одновременно, то сигналы, которые могут быть вызваны ловушками, доставляются первыми.  Одновременно могут обрабатываться дополнительные сигналы, каждый из которых будет прерывать обработчики предыдущих до выполнения их первых инструкций.  Набор ожидающих сигналов возвращается системным вызовом sigpending(2).  Когда подается пойманный сигнал, текущее состояние процесса сохраняется, вычисляется новая маска сигнала (как описано ниже) и вызывается обработчик сигнала.
Вызов обработчика организован таким образом, что если процедура обработки сигнала вернется нормально, то процесс возобновит выполнение в контексте, предшествующем подаче сигнала.  Если процесс хочет возобновить выполнение в другом контексте, то он должен сам восстановить предыдущий контекст.

Когда сигнал поступает в процесс, устанавливается новая маска сигнала на время работы обработчика сигнала процесса (или пока не будет выполнен системный вызов sigprocmask(2)).  Эта маска формируется путем объединения текущего набора сигнальных масок, сигнала который должен быть доставлен, и маски сигнала, связанной с вызываемым обработчиком.

Системный вызов sigaction() назначает действие для сигнала, указанного sig.  Если act ненулевое, оно определяет действие (SIG_DFL, SIG_IGN или подпрограмма-обработчик) и маску, которая будет использоваться при передаче указанного сигнала.  Если oact ненулевое значение, пользователю возвращается информация о предыдущей обработке сигнала.

После установки обработчика сигнала он обычно остается установленным до тех пор, пока не будет выполнен другой системный вызов sigaction() или не будет выполнен execve(2).  Действие по умолчанию, специфичное для сигнала, может быть сброшено установкой sa_handler в SIG_DFL.  По умолчанию это завершение процесса, возможно, с дампом ядра; бездействие; остановка процесса; или продолжение процесса.  Действие по умолчанию каждого сигнала см. в списке сигналов ниже.  Если sa_handler имеет значение SIG_DFL, то действием по умолчанию для сигнала является отбрасывание сигнала, а если сигнал ожидается, то отбрасывается и ожидаемый сигнал, даже если он замаскирован.  Если sa_handler имеет значение SIG_IGN, текущие и ожидающие экземпляры сигнала игнорируются и отбрасываются.

Опции могут быть заданы путем установки sa_flags.  Значение различных битов следующее:

SA_NOCLDSTOP    
Если этот бит установлен при установке функции перехвата    сигнала SIGCHLD, сигнал SIGCHLD будет генерироваться только при выходе дочернего процесса, а не при его остановке.

SA_NOCLDWAIT 
Если этот бит установлен при вызове функции sigaction() для сигнала SIGCHLD, то система не будет создавать зомби процессы, когда дочерние процессы вызывающего процесса завершаются.  Если вызывающий процесс впоследствии выдаст wait(2) (или эквивалент), он блокируется до тех пор, пока не завершатся все дочерние процессы вызывающего процесса, а затем возвращает значение -1 с errno, установленным в ECHILD.

SA_ONSTACK 
Если этот бит установлен, система передаст сигнал процессу, находящемуся в сигнальном стеке, указанном с помощью sigaltstack(2).

SA_NODEFER 
Если этот бит установлен, то последующие появления доставленного сигнала не маскируются во время выполнения обработчика.

SA_RESETHAND 
Если этот бит установлен, обработчик сбрасывается обратно в SIG_DFL в момент доставки сигнала.

SA_RESTART См. параграф ниже.

 SA_SIGINFO 
 Если этот бит установлен, предполагается, что на функцию-обработчик указывает член sa_sigaction из struct sigaction и должна соответствовать прототипу, показанному выше или ниже в EXAMPLES.  Этот бит не должен устанавливаться при назначении SIG_DFL или SIG_IGN.

Если во время выполнения системных вызовов, перечисленных ниже, будет пойман сигнал, вызов может быть принудительно завершен с ошибкой EINTR, вызов может вернуться с передачей данных короче, чем было запрошено, или может быть перезапущен. Перезапуск отложенных вызовов запрашивается установкой бита SA_RESTART в sa_flags.  К затронутым системным вызовам относятся open(2), read(2), write(2), sendto(2), recvfrom(2), sendmsg(2) и recvmsg(2) на канале связи или медленном устройстве (например, терминале, но не не обычный файл), а также во время выполнения wait(2) или ioctl(2).  Однако вызовы, которые уже были выполнены, не перезапускаются, а вместо этого возвращается частичный успех (например, короткий счетчик чтения).

После выполнения fork(2) или vfork(2) все сигналы, маска сигналов, стек сигналов и флаги перезапуска/прерывания наследуются дочерней системой.

 Системный вызов execve(2) восстанавливает действие по умолчанию для всех пойманных сигналов и переводит все сигналы в состояние на стеке пользователя.  Игнорируемые сигналы остаются игнорируемыми; маска сигнала остается прежней; сигналы, которые перезапускают ожидающие системные вызовы, продолжают это делать.

 ПРИМЕЧАНИЕ
 Поле sa_mask, указанное в act, не может блокировать SIGKILL или SIGSTOP.  Любая попытка сделать это будет молча проигнорирована.

Следующие функции либо реентерабельны, либо не прерываются сигналами и являются асинхронно-сигнальными.  Поэтому приложения могут вызывать их без ограничений из функций, ловящих сигналы:

Base Interfaces:
_exit(), access(), alarm(), cfgetispeed(), cfgetospeed(), cfsetispeed(), cfsetospeed(), chdir(), chmod(), chown(), close(), creat(), dup(), dup2(), execle(), execve(), fcntl(), fork(), fpathconf(), fstat(), fsync(), getegid(), geteuid(), getgid(), getgroups(), getpgrp(), getpid(), getppid(), getuid(), kill(), link(), lseek(), mkdir(), mkfifo(), open(), pathconf(), pause(), pipe(), raise(), read(), rename(), rmdir(), setgid(), setpgid(), setsid(), setuid(), sigaction(), sigaddset(), sigdelset(), sigemptyset(), sigfillset(), sigismember(), signal(), sigpending(), sigprocmask(), sigsuspend(), sleep(), stat(), sysconf(), tcdrain(), tcflow(), tcflush(), tcgetattr(), tcgetpgrp(), tcsendbreak(), tcsetattr(), tcsetpgrp(), time(), times(), umask(), uname(), unlink(), utime(), wait(), waitpid(), write().

Realtime Interfaces:

aio_error(), sigpause(), aio_return(), aio_suspend(), sem_post(), sigset().

ANSI C Interfaces:

strcpy(), strcat(), strncpy(), strncat(), and perhaps some others.

Extension Interfaces:

strlcpy(), strlcat().

Все функции, не вошедшие в приведенные выше списки, считаются небезопасными по отношению к сигналам.  Иными словами, поведение таких функций при вызове из обработчика сигналов не определено.  В общем случае функиця обработчика сигнала должна быть не более, чем установка флага; большинство других действий небезопасны.

Кроме того, хорошей практикой является создание копии глобальной переменной errno и ее восстановление перед возвратом из обработчика сигналов. Это защищает от побочного эффекта, когда errno устанавливается функциями, вызываемыми изнутри обработчика сигналов.

ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
Функция sigaction() возвращает значение 0 в случае успеха; в противном случае возвращается значение -1 и глобальная переменная errno устанавливается для указания ошибки.

ПРИМЕРЫ
Существует три возможных прототипа, которым может соответствовать обработчик:

    ANSI C:
        void handler(int);

    POSIX SA_SIGINFO:
        void handler(int, siginfo_t *info, ucontext_t *uap);

Функция-обработчик должна соответствовать прототипу SA_SIGINFO, если бит SA_SIGINFO установлен во флагах.  Затем на нее должен указывать член sa_sigaction из struct sigaction.  Обратите внимание, что не следует присваивать SIG_DFL или SIG_IGN таким образом.

Если флаг SA_SIGINFO не установлен, функция-обработчик должна соответствовать прототипу ANSI C или традиционному BSD и на нее должен указывать член sa_handler из struct sigaction.  На практике FreeBSD всегда посылает три аргумента функции и, поскольку прототип ANSI C является подмножеством, оба варианта будут работать.   Объявление членов sa_handler в включаемых файлах FreeBSD соответствует ANSI C (как того требует POSIX), поэтому указатель функции в стиле BSD должен быть приведен (к ANSI?), чтобы компиляция прошла без предупреждений.  Традиционный стиль BSD не переносится, и поскольку его возможности являются полным подмножеством обработчика SA_SIGINFO, его использование устарело.

Аргумент sig - это номер сигнала, одно из значений SIG... из <signal.h>.

Аргумент code обработчика в стиле BSD и член si_code аргумента info обработчика SA_SIGINFO содержат числовой код, объясняющий причину сигнала, обычно одно из значений SI_... из <sys/signal.h> или коды, специфичные для сигнала, например, одно из значений FPE_... для SIGFPE.

Аргумент uap обработчика POSIX SA_SIGINFO указывает на экземпляр ucontext_t.